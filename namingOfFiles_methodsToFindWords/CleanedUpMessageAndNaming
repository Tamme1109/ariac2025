import json
import os
import re

class AAAAA:

    def __init__(self):
        # Example part messages (string format copied from ROS)
        self.part1 = "{ariac_msgs.msg.PartPose(part=ariac_msgs.msg.Part(color=1, type=12), pose=geometry_msgs.msg.Pose(position=geometry_msgs.msg.Point(x=0.8550007468284273, y=0.6164772436066459, z=0.13498237281626518), orientation=geometry_msgs.msg.Quaternion(x=0.5000018616682316, y=-0.5000001177088924, z=0.49999993514050056, w=-0.4999980854752264)))" 
        self.part2 = "ariac_msgs.msg.PartPose(part=ariac_msgs.msg.Part(color=3, type=13), pose=geometry_msgs.msg.Pose(position=geometry_msgs.msg.Point(x=0.9250003189085374, y=0.23715737166987902, z=0.029984546719540428), orientation=geometry_msgs.msg.Quaternion(x=0.6123727136688034, y=0.3535447161264618, z=-0.6123713872805299, w=-0.35356339925547253)))"
        self.msg = [self.part1, self.part2]
        
        self.numberOfPartsSaved = 0
        self.script_dir = os.path.dirname(__file__)
        self.rel_path = f"savedInfo/saved_part_{self.numberOfPartsSaved}.json"
        self.abs_file_path = os.path.join(self.script_dir, self.rel_path)
        
    def get_msg(self):
        return self.msg

    def get_one_msg(self, index):
        return self.msg[index]

    def set_msg(self, index, msg):
        self.msg[index] = msg

    def cleanUpString(self, string):
        # Not currently used, but left here in case of future cleanup needs
        pattern = r',\s*|\s+|(?<=\d)\s+(?=\d)'
        result = str(re.split(pattern, string)).replace("ariac_msgs.msg.", "")
        result = (((result.replace("PartPose(", "")).replace("geometry_msgs.msg.Pose(position=geometry_msgs.msg." , "")).replace("geometry_msgs.msg.Point", "")).replace("geometry_msgs.msg.Quaternion", "")
        result = (result.replace("Part", "")).replace("Point", "")
        result = result[:-4]
        return result

    def cleanUpPartMsg(self, stringOfThings):
        # Extract numbers from the string and build a dict with the structure
        values = []
        text = ((str(stringOfThings).replace("=", "= ")).replace("'", " ' ")).replace(")", " )").replace(",", " , ")
        for t in text.split():
            try:
                values.append(float(t))
            except ValueError:
                pass

        vals = [int(values[0]), int(values[1]), [values[2], values[3], values[4]], [values[5], values[6], values[7]]]
        keys = ["color", "type", "pos", "rotation"]
        data = dict(zip(keys, vals))
        return data

    def generate_image_filename(self, part_data: dict, index=None):
        """
        Generates a descriptive image filename using part type, color, and rotation.
        Example: 'sensor_red_rot90_003.png'
        """
        types_of_parts = ['pump', 'battery', 'regulator', 'sensor']
        colours = ['blue', 'red', 'green', 'orange', 'purple']

        type_id = part_data["type"]
        color_id = part_data["color"]

        try:
            type_name = types_of_parts[type_id]
        except IndexError:
            type_name = f"type{type_id}"

        try:
            color_name = colours[color_id]
        except IndexError:
            color_name = f"color{color_id}"

        # Get rotation around Z axis and convert radians â†’ degrees
        rotation_z = part_data.get("rotation", [0, 0, 0])[2]
        rotation_deg = int(round(rotation_z * 180))

        if index is not None:
            filename = f"{type_name}_{color_name}_rot{rotation_deg}_{index:03d}.png"
        else:
            filename = f"{type_name}_{color_name}_rot{rotation_deg}.png"

        return filename

    def save_msg_to_json(self, dictionary):
        with open(self.abs_file_path, 'w', encoding='utf-8') as f:
            json.dump({"part": {f"part_nr:{self.numberOfPartsSaved}" :dictionary}}, f, ensure_ascii=False, indent=4)
        self.updateSaveFilePath()

    def updateSaveFilePath(self):
        self.numberOfPartsSaved += 1
        self.script_dir = os.path.dirname(__file__)
        self.rel_path = f"savedInfo/saved_part_{self.numberOfPartsSaved}.json"
        self.abs_file_path = os.path.join(self.script_dir, self.rel_path)

    def save_msg(self, newdata):
        script_dir = os.path.dirname(__file__)
        rel_path = "savedInfo/saved_parts.json"
        abs_file_path = os.path.join(script_dir, rel_path)

        f = open(abs_file_path)
        data = json.load(f)["parts"]
        f.close()
            
        data.update(newdata["parts"])

        with open(abs_file_path, 'w', encoding='utf-8') as f:
            json.dump({"parts": data}, f, ensure_ascii=False, indent=4)

# --- Testing block (only run when script is executed directly) ---
def main(args=None):
    """
    Test the part parsing and filename generation without using ROS.
    This just prints filenames based on the example messages inside AAAAA.
    """
    a = AAAAA()

    for i, msg in enumerate(a.get_msg()):
        cleaned = a.cleanUpPartMsg(msg)
        a.set_msg(i, cleaned)

        filename = a.generate_image_filename(cleaned, index=i)
        print(f"Image would be saved as: {filename}")

if __name__ == '__main__':
    main()
